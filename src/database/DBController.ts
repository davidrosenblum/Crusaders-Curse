import { Db, InsertOneWriteOpResult, DeleteWriteOpResultObject, FindAndModifyWriteOpResultObject } from "mongodb";
import { DBAccount } from "./DBAccount";
import { DBAccountSchema, DBSaltSchema, DBCharacterSchema, DBCharacterPreviewSchema, createDefaultCharacter } from "./DBSchema";
import { getArchetypeName, getMapName } from "../data/Data";
import { TokenGenerator } from "../utils/TokenGenerator";

export class DBController{
    private static readonly PASSWORD_SIZE:number = 64;
    private static readonly HASH_VALS:string[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890".split("");
    private static tokenGen:TokenGenerator = new TokenGenerator(DBController.PASSWORD_SIZE);

    private _database:Db;

    constructor(mongoDatabase:Db){
        this._database = mongoDatabase;
        this.createCollections();
    }

    private static salt(input:string):string{
        if(input.length < DBController.PASSWORD_SIZE){
            let size:number = DBController.PASSWORD_SIZE - input.length;
            return TokenGenerator.anyToken(size);
        }
        return "";
    }

    private static hash(input:string):string{
        let buffer:string[] = new Array<string>(input.length);

        for(let i:number = 0; i < buffer.length; i++){
            buffer[i] = DBController.HASH_VALS[
                (i + input.charCodeAt(i)) % DBController.HASH_VALS.length
            ];
        }

        return buffer.join("");
    }

    private createCollections():void{
        this._database.createCollection("accounts", (err, res) => {
            this._database.collection("accounts").createIndex("username");
        });

        this._database.createCollection("salts", (err, res) => {
            this._database.collection("salts").createIndex("username");
        });

        this._database.createCollection("characters", (err, res) => {
            this._database.collection("characters").createIndex("name");
        });
    }

    public createAccount(username:string, password:string, accessLevel:number=1):Promise<string>{
        return new Promise((resolve, reject) => {
            let salt:string = DBController.salt(password);
            let hash:string = DBController.hash(password + salt);

            // account ID will be generated by mongo so its not here (uses objectID)
            let account:DBAccountSchema = {
                username,
                password: hash,
                access_level: accessLevel,
                enabled: true,
                date_joined: Date.now()
            };
    
            this._database.collection("accounts").insertOne(account)
                .then(result => {
                    if(result){
                        this.storeSalt(username, salt)
                            .then(() => resolve(`Account ${username} created.`))
                            .catch(err => reject(err));
                        
                    }
                    else reject(new Error(`Unable to create account ${username}.`));
                })
                .catch(err => reject(err));
        });
    }

    public getAccount(username:string, password:string):Promise<DBAccount>{
        return new Promise((resolve, reject) => {
            this._database.collection("accounts").findOne({username})
                .then(result => {
                    if(result){
                        let account:DBAccountSchema = result;

                        this.getSalt(username)
                            .then(saltDoc => {
                                let hash:string = DBController.hash(password + saltDoc.salt);

                                if(hash === account.password){
                                    if(account.enabled){
                                        resolve(new DBAccount(account.accountID, account.username));
                                    }
                                    else reject(new Error("Account is disabled."));
                                    
                                }
                                else reject(new Error("Wrong password."));
                            })
                            .catch(err => reject(err));
                    }
                    else reject(new Error(`Username "${username}" not found.`));
                })
                .catch(err => reject(err));
            
        });
    }

    private storeSalt(username:string, salt:string):Promise<InsertOneWriteOpResult>{
        let saltDoc:DBSaltSchema = {username, salt};
        return this._database.collection("salts").insertOne(saltDoc);
    }

    private getSalt(username:string):Promise<DBSaltSchema>{
        return new Promise((resolve, reject) => {
            this._database.collection("salts").findOne({username})
                .then(result => result ? resolve(result) : reject(new Error("Salt not found.")))
                .catch(err => reject(err));
        });
    }

    public createCharacter(accountID:number, archetypeID:number, name:string, skin:number=1):Promise<InsertOneWriteOpResult>{
        let characterDoc:DBCharacterSchema = createDefaultCharacter(accountID, archetypeID, name, skin);
        return this._database.collection("characters").insertOne(characterDoc);
    }

    public deleteCharacter(accountID:number, name:string):Promise<DeleteWriteOpResultObject>{
        return this._database.collection("characters").deleteOne({account_id: accountID, name});
    }

    public getCharacter(accountID:number, name:string):Promise<DBCharacterSchema>{
        return new Promise((resolve, reject) => {
            this._database.collection("characters").findOne({accountID, name})
                .then(data => {
                    if(data){
                        resolve(data as DBCharacterSchema);
                    }
                    else reject(new Error(`Character ${name} not found.`));
                })
                .catch(err => reject(err));
        });
    }

    public getCharacterList(accountID:number):Promise<DBCharacterPreviewSchema[]>{
        return new Promise((resolve, reject) => {
            this._database.collection("characters").find({accountID}).toArray()
                .then(results => {
                    let previews:DBCharacterPreviewSchema[] = new Array<DBCharacterPreviewSchema>(results.length);

                    results.forEach((result, index) => {
                        previews[index] = {
                            name:       result.name,
                            map:        getMapName(result.map_id),
                            archetype:  getArchetypeName(result.archetype_id),
                            level:      result.level
                        };
                    });

                    resolve(previews);
                })
                .catch(err => reject(err));
        });
    }

    public updateCharacter(data:DBCharacterSchema):Promise<FindAndModifyWriteOpResultObject>{
        let name:string = data.name;
        return this._database.collection("characters").findOneAndUpdate({name}, data);
    }
}