import { Db, InsertOneWriteOpResult } from "mongodb";
import { DBAccount } from "./DBAccount";
import { DBAccountSchema, DBSaltSchema } from "./DBSchema";
import { TokenGenerator } from "../utils/TokenGenerator";

export class DBController{
    private static readonly PASSWORD_SIZE:number = 64;
    private static readonly HASH_VALS:string[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890".split("");
    private static tokenGen:TokenGenerator = new TokenGenerator(DBController.PASSWORD_SIZE);

    private _database:Db;

    constructor(mongoDatabase:Db){
        this._database = mongoDatabase;
    }

    private static salt(input:string):string{
        if(input.length < DBController.PASSWORD_SIZE){
            let size:number = DBController.PASSWORD_SIZE - input.length;
            return TokenGenerator.anyToken(size);
        }
        return "";
    }

    private static hash(input:string):string{
        let buffer:string[] = new Array<string>(input.length);

        for(let i:number = 0; i < buffer.length; i++){
            buffer[i] = DBController.HASH_VALS[
                (i + input.charCodeAt(i)) % DBController.HASH_VALS.length
            ];
        }

        return buffer.join("");
    }

    public createAccount(username:string, password:string, accessLevel:number=1):Promise<string>{
        return new Promise((resolve, reject) => {
            let salt:string = DBController.salt(password);
            let hash:string = DBController.hash(password + salt);

            // account ID will be generated by mongo so its not here (uses objectID)
            let account:DBAccountSchema = {
                username,
                password: hash,
                access_level: accessLevel,
                enabled: true,
                date_joined: Date.now()
            };
    
            this._database.collection("accounts").insertOne(account)
                .then(result => {
                    if(result){
                        this.storeSalt(username, salt)
                            .then(() => resolve(`Account ${username} created.`))
                            .catch(err => reject(err));
                        
                    }
                    else reject(new Error(`Unable to create account ${username}.`));
                })
                .catch(err => reject(err));
        });
    }

    public getAccount(username:string, password:string):Promise<DBAccount>{
        return new Promise((resolve, reject) => {
            this._database.collection("accounts").findOne({username})
                .then(result => {
                    if(result){
                        let account:DBAccountSchema = result;

                        this.getSalt(username)
                            .then(saltDoc => {
                                let hash:string = DBController.hash(password + saltDoc.salt);

                                if(hash === account.password){
                                    if(account.enabled){
                                        resolve(new DBAccount(account.accountID, account.username));
                                    }
                                    else reject(new Error("Account is disabled."));
                                    
                                }
                                else reject(new Error("Wrong password."));
                            })
                            .catch(err => reject(err));
                    }
                    else reject(new Error(`Username "${username}" not found.`));
                })
                .catch(err => reject(err));
            
        });
    }

    private storeSalt(username:string, salt:string):Promise<InsertOneWriteOpResult>{
        let saltDoc:DBSaltSchema = {username, salt};
        return this._database.collection("salts").insertOne(saltDoc);
    }

    private getSalt(username:string):Promise<DBSaltSchema>{
        return new Promise((resolve, reject) => {
            this._database.collection("salts").findOne({username})
                .then(result => result ? resolve(result) : reject(new Error("Salt not found.")))
                .catch(err => reject(err));
        });
    }
}